# Query REST

Формат параметров запроса и ответа в REST API. 
Для выборки связанных данных одним запросом. 
Спецификация является рекомендательной и не обязывает реализовывать все опции. Опции отмечены
по уровню востребованности ![v1](v1.png) ![v2](v2.png) ![v3](v3.png).

## Содержание

__Запрос__
* __[`fields`](#fields)__ — запрашиваемые данные.
  * [По умолчанию](#fields)![v1](v1.png)
  * [Все свойства](#fields--)![v1](v1.png)&ensp; `*`
  * [Выборочные свойства](#fields--prop1-prop2prop3)![v1](v1.png)&ensp; `prop1, prop2(prop3)`
  * [Свойства списка](#fields--itemsprop-count)![v2](v2.png)&ensp; `items(prop), count`
  * [Исключение свойств](#fields--prop)![v3](v3.png)&ensp; `!prop` 
  * [Зависимость от типа объекта](#fields--proptype1prop1-type2prop2)![v3](v3.png)&ensp; `prop(type1:prop1, type2:prop2)`
  * [Рекурсивные шаблоны](#fields--commentstext-children)![v3](v3.png)&ensp; `comments(text, children(^))`
* __[`search`](#search)__ — условие выборки.
  * [Равенство значению](#searchprop1--value)![v1](v1.png)&ensp; `search[prop]=value` 
  * [Вхождение в строку](#searchprop2--value)![v2](v2.png)&ensp; `search[prop]=*value` 
  * [Вхождение с сначала строки](#searchprop3--value)![v2](v2.png)&ensp; `search[prop]=^value` 
  * [Полнотекстовый поиск](#searchprop4--value)![v2](v2.png)&ensp; `search[prop]=~value` 
  * [Регулярное выражение](#searchprop5--value)![v2](v2.png)&ensp; `search[prop]=/value/` 
  * [Неравенство значению](#searchprop6--value)![v2](v2.png)&ensp; `search[prop]=!value` 
  * [Равенство значению со спец. символами](#searchprop7--value-with)![v2](v2.png)&ensp; `search[prop]="value-with!~^*<>;|` 
  * [Больше, меньше значения](#searchprop8--value-searchprop--value)![v2](v2.png)&ensp; `search[prop]=>value`,&ensp; `search[prop]=<value`  
  * [Больше или равно, меньше или равно](#searchprop9--value-searchprop--value)![v2](v2.png)&ensp; `search[prop]=>>value`,&ensp; `search[prop]=<<value` 
  * [Диапазон значений](#searchprop10--minmax)![v2](v2.png)&ensp; `search[prop]=min;max` 
  * [Интервал значений](#searchprop11--minmax)![v2](v2.png)&ensp; `search[prop]=min~max` 
  * [Вне диапазона значений](#searchprop12--minmax)![v2](v2.png)&ensp; `search[prop]=!min;max` 
  * [Вне интервала значений](#searchprop13--minmax)![v2](v2.png)&ensp; `search[prop]=!min~max` 
  * [Отсутствие свойства или значения](#searchprop14--null)![v2](v2.png)&ensp; `search[prop]=null` 
  * [Выполнение любого условия](#searchprop15--exp1exp2)![v2](v2.png)&ensp; `search[prop]=exp1|exp2` 
  * [Выполнение всех условий](#searchprop16--exp1exp2)![v2](v2.png)&ensp; `search[prop]=exp1&exp2` 
  * [Не выполнение любого условия](#searchprop17--exp1exp2)![v2](v2.png)&ensp; `search[prop]=!exp1|!exp2` 
  * [Не выполнение всех условий](#searchprop18--exp1exp2)![v2](v2.png)&ensp; `search[prop]=!exp1&!exp2` 
  * [Условие по вложенному свойству](#searchprop1prop2--value)![v1](v1.png)&ensp; `search[prop1.prop2]=value` 
  * [Условие по свойству в неопределенной вложенности](#searchprop1parentprop3--value)![v3](v3.png)&ensp; `search[prop1..parent.prop3]=value`
  * [Условие фильтрации свойства](#searchprop1prop--value)![v3](v3.png)&ensp; `search.prop1[prop]=value`
* __[`sort`](#sort)__![v1](v1.png) — сортировка.
  * [По одному полю](#sort--prop)![v1](v1.png)&ensp; `sort=prop`
  * [Обратная сортировка](#sort---prop)![v1](v1.png)&ensp; `sort=-prop`
  * [По вложенному свойству](#sort--prop1prop2prop3)![v1](v1.png)&ensp; `sort=prop1.prop2.prop3`
  * [По нескольким свойствам](#sort---prop1-prop2)![v2](v2.png)&ensp; `sort=-prop1, prop2`
  * [Сортировка в множественном свойстве](#sortprop1--prop2prop3)![v3](v3.png)&ensp; `sort.prop1 = prop2.prop3`
* __[`limit`](#limit)__![v1](v1.png) — ограничение количества.
  * [По умолчанию](#limit-)![v1](v1.png)
  * [Не больше указанного](#limit--10)![v1](v1.png)&ensp; `limit=10`
  * [Без ограничений](#limit--)![v2](v2.png)&ensp; `limit=*`
  * [В множественом свойстве](#limitprop--10)![v3](v3.png)&ensp; `limit.prop=10`
* __[`skip`](#skip)__![v1](v1.png) — с какой позиции ограниченное количество.
  * [С указанной](#skip--10)![v1](v1.png)&ensp; `skip=10`
  * [В множественом свойстве](#skipprop--10)![v3](v3.png)&ensp; `skip.prop=10`
* __[`depth`](#depth)__![v3](v3.png) — ограничение вложенности.
  * [По умолчанию](#depth-)![v3](v3.png)
  * [Не больше указанного](#depthprop--10)![v3](v3.png)&ensp; `depth.prop=10`
  * [Без ограничений](#depthprop--)![v3](v3.png)&ensp; `depth.prop=*`
* __[`lang`](#lang)__![v2](v2.png) — язык при мультиязычности.
  * [По умолчанию](#lang-)![v2](v2.png)
  * [Для всех свойств](#lang--en)![v2](v2.png)&ensp; `lang=en`
  * [Все варинты языков](#lang--)![v2](v2.png)&ensp; `lang=*`
  * [Несколько языков](#lang--en-ru)![v3](v3.png)&ensp; `lang=en, ru`
  * [Для одного свойства](#langprop--en)![v3](v3.png)&ensp; `lang.prop=en`

__Ответ__
* __[`result`](#ответ)__ — успешный результат.
  * [Один объект](#однин-объект)![v1](v1.png) &ensp; `{"result":{}}`
  * [Список объектов](#список-объектов)![v1](v1.png) &ensp; `{"result":{"items":[]}}`
* __[`error`](#ошибки)__ — ошибки запроса.
  * [Общая информация](#ошибки)![v1](v1.png)&ensp; `{"error":{"code":"400", "message":"", "data":{}}}`
  * [Ошибки в полях](#ошибки)![v2](v2.png)&ensp; `{"error":{"data":{"fields:[]}}}`
  

# Запрос

Спецификация определяет query параметры запроса для указания что выбрать, с каким 
условием, сортировокой и ограничением. Параметры опциональные, допускается их переименовывание
и применение дополнительных. URL запроса любой.

```
GET /objects?fields=name,author(age)&search[author.age]=18;30&sort=-name&limi=10&skip=0&lang=ru
```

# `fields`

Названия свойств и отношений объекта, которые нужно получить одним запросом. 

> Альтернативные названия: data, props, select

В классическом REST API структура ответа жестко определяется сервером. Клиент получает лишние 
данные, либо сталкивается с нехваткой нужных. Например, связанные объекты нужно запрашивать 
отдельными запросами, имея их идентфикатор. Обработка параметра `fields` решает эту проблему. 
Одним запросом можно выбрать все необходимые связанные данные и не запрашивать лишние.

Параметр `fields` реализуется не только в GET запросах, но и в запросах создания, изменения и 
удаления объектов. В каждом запросе, который способен вернуть объект. 

Предполагается, что в `fields` указываются свойства объектов. Но если реализовать api роут для
доступа к корню всех данных, то в `fields` будут указываться названия коллекций (типов, таблиц, множеств).
В этом случаи, действительно, одним запросом можно выбрать абсолютно все необходимые данные.

```
GET root?fields=users(email,phone), news(title, text), categories(name, rating)
```

Формат параметра `search` позволяет на каждое свойство определить условие выборки (фильтра).

#### `fields =`

Если параметр `fields` не указан или равен пустой строке, то сервер возвращает минимальный набор 
данных исходя из своих настроек. Обычно возвращается только идентификатор объекта. 

```json
{
  "result": {
    "id": 1
  }
}
```

#### `fields = *`

Символ `*` указывает на выбор всех непосредственных свойств объекта. С учётом их доступности на 
сервере. Выборка свойств связанных объектов не выполняется — только их внешние ключи. 

```json
{
  "result": {
    "id": 1,
    "type": "some",
    "name": "Test object",
    "status": "new",
    "profile": {
      "phone":"+79996665544",
      "avatar":{
        "id": 23,
        "type": "file"
      }
    }
  }
}
```

В данном примере `profile` является вложенным объектом (не отношением), а аватарка является 
отношением на объект с типом `file` и идентификатором `23`. Для выборки свойств аватарки нужно их явно 
указать в `fields`.

#### `fields = prop1, prop2(prop3)`

Конкретные свойства объекта указываются через запятую. Допустимы пробелы, переводы строк, табы.
Для вложенности используются круглые скобки. Идентфикатор объекта возвращается всегда (свойства по
умолчанию).

```
GET /some/1?fields=name, profile(avatar(url, extension), prop3)
```
```json
{
  "result": {
    "id": 1,
    "name": "Test object",
    "profile": {
      "avatar": {
        "url": "/uploads/1928-212/5c2f3ed1fee590496c63759f.png",
        "extension": "png"
      },
      "prop3": null
    }
  }
}
```

Если запрашиваемое свойство у объекта отсутствует, то в ответе оно будет с null значением. 
То есть в любом случаи свойство возвращается.

#### `fields = items(prop), count`

Свойства списка. Если сервер возвращает список объектов, то `fields` применяется к каждому объекту списка. 
Чтобы одним запросом запросить свойства самого списка, например общее количество объектов, 
удовлетворяющих условию без ограничений, то запрашиваемые свойства нужно вложить в `items` и через
запятую указывать свойства списка. Структура ответа будет консистента запросу.

```
GET /some/1?fields=items(name, profile(phone)), count
```
```json
{
  "result": {
    "items": [
      {
        "id": 1,
        "name": "Test object",
        "profile": {
          "phone":"+79996665544"
        }
      },
      {
        "id": 3,
        "name": "Test object 3",
        "profile": {
          "phone":"+79996665555"
        }
      }
    ],
    "count": 105
  }
}
```

Какие именно свойства есть у списка зависит от реализации АПИ, по умолчанию доступен `count`. 
Можно реализовать выборку средних, минимальных значений, но чаще функции агрегации реализуются 
отдельными запросами.

#### `fields = !prop`

Исключение свойства. Если у объекта много свойств и только одно из них не требуется возвращать, то 
вместо перечисления длинного списка возвращаемых свойств с исключением одного, можно применить 
отрицание свойства. 

Сначала указывается, что нужны все свойства символом `*`, далее через запятую свойства, которое исключить
с символом `!`. Если не указать `*`, то исключение будет из свойств, возвращаемых по умолчанию.

```
GET /some/1?fields=*, !name, !profile
```
```json
{
  "result": {
    "id": 1,
    "type": "some",    
    "status": "new"
  }
}
```

#### `fields = prop(type1:prop1, type2:prop2)`

Зависимость от типа объекта. В списке запрашиваемых объектов одно и тоже отношение может отличаться 
типом связанного объекта.

Например, "объекты избранного" могут ссылаться на пользователя, статью, товар и прочие типы объектов. 
Соответственно, доступные свойства отношения будут различаться. Если в fields указать свойства
пользовтеля, то для статьи они окажутся `null`. 

Чтобы не возвращать `null`, нужно в fields указывать свойства для конкретного типа объекта.
Перед именем свойства указывается название типа объекта, разделяя двоеточием `:`

```
GET /favorites?fields=relative(user:surname, product:price(value, unit), product:title)
```  
```json
{
  "result": {
    "items": [
      {
        "_id": "5c2f3ed1fee590496c93779d",
        "relative": {
          "_id": "5c2f3ed1fee590496c935678",
          "_type": "user",
          "surname": "UserSurname"
        }
      },
      {
        "_id": "5c2f3ed1fee590496c93778f",
        "relative": {
          "_id": "5c2f3ed1fee590496c935608",
          "_type": "product",
          "price": {
            "value": 100,
            "unit": "USD"
          },
          "title": "ProductTitle"
        }
      }
    ]
  }
}
```

Тип можно указывать для любых свойств, не только свойств отношений. Например, пользователи могут 
отличаться типом за счёт наследования. В одном списке будут админы, менеджеры и другие типы 
пользователей с различными свойствами. Уместно применять типизацию в `fields` для выборки 
исключительных свойств, например, админа или менеджера.

#### `fields = comments(text, children(^))`

Рекурсивные шаблоны. Символом `^` указывается ссылка на перечень полей уровнем выше скобки. 
Используется для выборки рекурсивных отношений (иерархий). Например, у каждого комментария есть 
свойство children с вложенными комментриями, у которых тоже есть вложенные комментарии. 

Запрос без `^` выглядел бы так:

```
GET /news?fields=text, comments(text, children(text, children(text, children(text, children))
```

Примером выше описана выборка на три уровня вложеннности, но вложенность может быть гораздо больше.
Чтобы определить поля на любой уровень вложенности применяется ссылка на шаблон полей.

```
GET /news?fields=text, comments(text, children(^))
```

Ссылка относительная. Чтобы сделать ссылку на два и более уровней выше (на шаблон за второй скобкой), 
указывается соответсвующее количество символов `^`.

```
GET /product?fields=title, brand(name, products(title, brand(name, products()))
GET /product?fields=title, brand(name, products(^^))
```

# `search`

Условие выборки.

> Альтернативные названия: filter, cond, where

Параметром `search` указываются условия на свойства искомых объектов. Условием может быть равенство
значению, вхождение в диапазон, перечень значений и дургие. Допустимо указывать виртуальные свойства 
(поля), по которым формируются сложные условия на стороне бэкенда. 

Параметром указавается множество условий на разные поля. Названия полей в квадратных
скобок. Формат не определяет как логически все условия будут соединены — через И, ИЛИ, НЕ. 
Зависит от реализации сервера. Обычно условия соединяются через И. На усмотрнение сервера конкретные 
условия объединять в соответствии с задачами АПИ.

Параметром `search` не определяются все возможные условия, в ином  случаи он станет слишком сложным 
для использования и интерпретации сервером.

#### `search[prop1] = value`

Равенство значению. Условие равенства `search[prop1]=value` сервер может реализовывать по любой логике, не обязательно
строгим сравнением.  

#### `search[prop2] = *value`

Вхождение в строку.

#### `search[prop3] = ^value`

Вхождение с сначала строки.

#### `search[prop4] = ~value`

Полнотекстовый поиск.

#### `search[prop5] = /value/`

Регулярное выражение.

#### `search[prop6] = !value`

Неравенство значению.

#### `search[prop7] = "value-with!~^*<>;|`

Равенство значению со спец. символами.

#### `search[prop8] = >value`, `search[prop] = <value`

Больше, меньше значения.

#### `search[prop9] = >>value`, `search[prop] = <<value`

Больше или равно, меньше или равно.

#### `search[prop10] = min;max`

Диапазон значений.

```
search[price]=100;200  // Цена в диапазоне от 100 до 200 включительно
```

#### `search[prop11] = min~max`

Интервал значений.

#### `search[prop12] = !min;max`

Вне диапазона значений.

#### `search[prop13] = !min~max`

Вне интервала значений.

#### `search[prop14] = null`

Отсутствие свойства или значения.

#### `search[prop15] = exp1|exp2`

Выполнение любого условия.

#### `search[prop16] = exp1&exp2`

Выполнение всех условий.

#### `search[prop17] = !exp1|!exp2`

Не выполнение любого условия.

#### `search[prop18] = !exp1&!exp2`

Не выполнение всех условий.

#### `search[prop1.prop2] = value`

Условие по вложенному свойству.

#### `search[prop1..parent.prop3] = value`

Условие по свойству в неопределенной вложенности.

#### `search.prop1[prop] = value`

Условие фильтрации свойства.

Условие может быть как на выбираемое множество объектов, так и на конкретное свойство объекта 
(обычно тоже множественное). Например, у товара множество точек продаж, выбирая сам товар, можем 
ограничить список точек продаж по определенному условию.

Через точку указывается, к какому свойству применить условие фильтра. Будет отфильтровано
само свойство у выбранных объектов.

```
search.stores[title]=*Magnit  // Магазины отфильтровать по названию - содержат Magnit
```

# `sort`

Сортировка списков.

> Альтернативные названия: order

#### `sort = prop` 

Сортировка по одному свойству по возрастанию. Указывается название свойства. Направление 
сортировки может задавать сервер.

#### `sort = -prop`

Указание направления сортировки. По убыванию (desc) с символом минус `-` перед названием свойства 
без пробела. По возрастанию (asc) без символа. 

#### `sort = prop1.prop2.prop3`

Сортировка по вложенному свойству (вложенного объекта или отношения). Название свойства указывается 
через точки в виде пути на него.

```
sort = contacts.address.street // сортировка (магазинов) по улице в адресе контактов
```

#### `sort = -prop1, prop2`

Сортировка по нескольким свойствам. Названия свойств перечисляются через запятую. 
Допустимы пробельные символы

```
sort = -price,date //Сортировка по убыванию цены и возаратсанию даты
```

#### `sort.prop1 = prop2.prop3`

Сортировка внутри множественного свойства объекта. Название сортируемого свойства указывается
в названии параметра sort, а по какому полю — в значении.

```
sort.stores=title // Список магазинов отсортировать по названию магазинов
```

# `limit`

Ограничение количества возвращаемых объектов в списке.

> Альтернативные названия: count, size, length

#### `limit =`

Если параметр `limit` не передан или равен пустой строке, то сервер использует значние по умолчанию
на своё усмотрение, обычно в пределах 100.

#### `limit = 10`

Ограничение количества целым числом. Сервер должен вернуть не больше указнного количества. 
Может вернуть меньше.

#### `limit = *`

Без ограничений выбрать все объекты. Допускается в редких случаях, когда действительно есть
необходимость гарантировано получить все объекты.

#### `limit.prop = 10`

Ограничение внутри множественного свойства объекта. Название ограничиваемого свойства указывается
в названии параметра `limit`  через точку.

```
limit.comments=10
```

# `skip`

Позиция, с которой вернуть ограниченное количество объектов в списке.
По умолчанию `skip` равен нулю, сервер возвращает список начиная с первого объекта.

> Альтернативные названия: offset, seek, position

#### `skip = 10`

Позиция целым числом. Если позиция больше чем общее количество объектов, то сервер вернут ноль
объектов.

#### `skip.prop = 10`

Сдвиг внутри множественного свойства объекта. Название свойства указывается
в параметре `skip` через точку.

```
skip.comments=10
```

# `depth`

Ограничение вложенности (глубины) при выборке иерерхических структур или рекурсивных связей.
Обычно указывается для свойств объекта. Так как вложенная структура образуется выборкой 
свойств объекта.

> Альтернативные названия: level

#### `depth =`

Если параметр `depth` не передан или равен пустой строке, то сервер использует значение по умолчанию
по своему усмотрению. `depth` используется только для [рекурсивных `fields`](#fields--commentstext-children).

#### `depth.prop = 10`

Ограничение максимальной вложенности рекурсивных свойств (связей) целым числом. 
Название свойства указывается в параметре `depth` через точку.

_Выбор дерева страниц 2 уровня и комменответов на 4 уровня вложенности_
```
GET /pages?depth.chilren=2&depth.comments=4
```

#### `depth.prop = *`

Выбрать всю вложенность рекурсивных свойств объекта. Используется с осторожностью, если есть 
гарантия незацикленности рекурсивных связей. 
Например, иерархию комментриев допустимо выбрать сразу всю. Но если выбирается рекурсивное свойство 
"друг" у пользователя, то на каком-то уровне свойство "друг" может указывать на исходного 
пользователя и тем самым глубина выборки окажется бесконечной.


# `lang`

Параметр языка для мультиязычных свойств. Для выборки объектов со свойствами в нужном языке. 
По подобию параметра `lang` можно указывать валюту `unit` для цен, версию изменений `ver` и другие.


#### `lang =`

Если параметр `lang` не передан или равен пустой строке, то для мультиязычных свойств используется
язык по умолчани. Язык по умолчанию может определяться по установкам аккаунта, заголовкам HTTP или 
иначе.

#### `lang = en`

Указание языка для всех мультиязычных свойств объекта. Код языка зависит от специфики проекта. 

```
lang=en
```
```json
{
   "title": "Title"
}
```

#### `lang = *`

Вернуть свойства во всех языках, для которых есть перевод. Стуктура ответа при этом
зависит от особенностей проекта. Предполагается, что мультиязычные свойства получат дополнительную
вложенность в виде объекта с ключами, равным кодам языков.

```
lang=*
```
```json
{
   "title": {
     "ru": "Заголвоок",
     "en": "Title",
     "it": "Testata"
   }
}
```

#### `lang = en, ru`

Выбор свойств в указанных языках. Логика аналогична выбору свойств во всех языках.

#### `lang.prop = en`

Указание языка для конкретного свойства объекта.
Название свойства указывается в параметре `lang` через точку.

```
lang.stores.title=ru  // язык для заголовка магазинов
```

# Ответ

Любой ответ от сервера возвращается в JSON. Базовая структура ответа едина для всех запросов.

#### Однин объект

Запрашиваемый объект или скалярное значение возвращается в свойстве `result`. 
Это необходимо, чтобы любой ответ сервера был валидным JSON.

```json
{
  "result": "object or value"
}
```

#### Список объектов

Элементы списка возвращаются в свойстве `result.items`. В result могут быть дополнительные данные,
например общее количество объектов для пагинации или количество страниц с учётом ограничений выборки.

```json
{
  "result": {
    "items": ["object or value", "object or value"],
    "count": 19822
  }
}
```

#### Ошибки

Поддержка всех HTTP кодов форматом не определется. Достаточно различать успешные 2xx и ошибочные запросы 4xxx
в соответсвии с логикой проекта.

Если сервер возвращает информацию об ошибке, то она прописывается в свойсте `error`. 
Свойство `error.data` содержит подробности об ошибке, например информацию про каждое ошибочное поле 
формы.

```json
{
  "error": {
    "code": "400.42143",
    "message": "Some error",
    "data": {
      "fields": [
        {"path": "profile.phone", "message": "Not unique", "code": "unique"},
        {"path": "profile.phone", "message": "Bad format", "code": "format"}
      ]
    }  
  }
}
```

Предполагается, что у одного поля формы может быть несколько разных ошибок. В предыдущем примере
все ошибки полей возвращаются массивом, а значение `path` элементов массива может дублироваться.
