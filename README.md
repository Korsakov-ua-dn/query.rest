# Query REST

Формат параметров запроса и ответа в REST API. 
Для выборки связанных данных одним запросом. 
Спецификация имеет минимальную версию ![v1](v1.png) и расширенные ![v2](v2.png) ![v3](v3.png).
При реализации спецификации указывается полностью поддерживаемая версия.

### [Ответ](#ответ)
1. [Один объект](#однин-объект)![v1](v1.png)  `{result:{}}`
2. [Список объектов](#список-объектов)![v1](v1.png)  `{result:{items:[]}`
3. [Ошибки](#ошибки)![v1](v1.png) `{error:{}}`

### [Запрос](#Запрос)
__[`fields`](#fields)__ - что выбрать.
1. [По умолчанию](#fields)![v1](v1.png)
2. [Все свойства](#fields--)![v1](v1.png) - `*`
3. [Выборочные свойства](#fields--prop1-prop2prop3)![v1](v1.png)   - `prop1, prop2(prop3)`
4. [Свойства списка](#fields--itemsprop-count)![v2](v2.png) - `items(prop), count`
5. [Исключение свойств](#fields--prop)![v2](v2.png) - `!prop` 
6. [Зависимость от типа объекта](#fields--proptype1prop1-type2prop2)![v3](v3.png) - `prop(type1:prop1, type2:prop2)`
7. [Рекурсивные шаблоны](#fields--commentstext-children)![v3](v3.png)  - `comments(text, children(^))`
  
__[`search`](#search)__ - условие выборки.
1. [Равенство значению](search.md)![v1](v1.png) - `search[prop1]=value` 
2. [Вхождение в строку](search.md)![v2](v2.png) - `search[prop1]=*value` _{String}_
3. [Вхождение с сначала строки](search.md)![v2](v2.png) - `search[prop1]=^value` _{String}_
4. [Полнотекстовый поиск](search.md)![v2](v2.png) - `search[prop1]=~value` _{String}_
4. [Регулярное выражение](search.md)![v2](v2.png) - `search[prop1]=/value/` _{String}_
5. [Неравенство значению](search.md)![v2](v2.png) - `search[prop1]=!value` 
6. [Равенство значению со спец. символами](search.md)![v2](v2.png) - `search[prop1]="value-with!~^*<>;|` _{String}_
7. [Больше, меньше значения](search.md)![v2](v2.png) - `search[prop1]=>value`, `search[prop1]=<value`  _{Number|Date}_
8. [Больше или равно, меньше или равно](search.md)![v2](v2.png) - `search[prop1]=>>value`, `search[prop1]=<<value` _{Number|Date}_
9. [Диапазон значений](search.md)![v2](v2.png) - `search[prop1]=min;max` _{Number|Date}_
10. [Интервал значений](search.md)![v2](v2.png) - `search[prop1]=min~max` _{Number|Date}_
11. [Вне диапазона значений](search.md)![v2](v2.png) - `search[prop1]=!min;max` _{Number|Date}_
10. [Вне интервала значений](search.md)![v2](v2.png) - `search[prop1]=!min~max` _{Number|Date}_
11. [Отсутствие свойства или значения](search.md)![v2](v2.png) `search[prop1]=null` _{Null}_
12. [Выполнение любого условия](search.md)![v2](v2.png) - `search[prop1]=exp1|exp2` 
13. [Выполнение всех условий](search.md)![v2](v2.png) - `search[prop1]=exp1&exp2` 
12. [Не выполнение любого условия](search.md)![v2](v2.png) - `search[prop1]=!exp1|!exp2` 
14. [Не выполнение всех условий](search.md)![v2](v2.png) - `search[prop1]=!exp1&!exp2` 
15. [Условие по вложенному свойству](search.md)![v1](v1.png) - `search[prop1.prop2]=value` 
16. [Условие по свойству в неопределенной вложенности]()![v3](v3.png) - `search[prop1..parent.title]=value`
17. [Условие фильтрации свойства](search.md)![v3](v3.png) - `search.prop1[prop2]=value`
  
__[`sort`](#sort)__ - сортировка.
  1. [По убыванию]()![v1](v1.png) - `sort=-name`
  2. [По нескольким свойствам]()![v1](v1.png) - `sort=-name,date`
  3. [По вложенным свойствам]()![v1](v1.png) - `sort=contacts.address.street`
  4. [Сортировка в множественном свойстве]()![v3](v3.png) - `sort.contacts=address.street`
  
__[`limit`](#limit-skip)__ - ограничение количества.
  1. [По умолчанию]()![v1](v1.png)
  2. [Не больше указанного]()![v1](v1.png) - `limit=10`
  3. [В множественом свойстве]()![v3](v3.png) - `limit.comments=10`

__[`skip`](#limit-skip)__ - с какой позиции ограниченное количество.
  1. [С указанной]()![v1](v1.png) - `skip=10`
  2. [В множественом свойстве]()![v3](v3.png) - `skip.comments=10`
  
__[`depth`](#depth)__ - ограничение вложенности.
  1. [По умолчанию]()![v3](v3.png)
  2. [Для свойства]()![v3](v3.png) - `depth.parent=10`

__[`lang`](#lang-unit-version)__ - язык при мультиязычности.
  1. [Для всех свойств]()![v2](v2.png) `lang=en`
  2. [Все варинты языков]()![v2](v2.png) - `lang=*`
  3. [Несколько языков]()![v3](v2.png) - `lang=ru,en`
  4. [Для одного свойства]()![v3](v3.png) - `lang.title=en`


## Ответ

Любой ответ от сервера возвращается в JSON. Базовая структура ответа едина для всех запросов.

#### Однин объект

Запрашиваемый объект или скалярное значение возвращается в свойстве `result`. 
Это необходимо, чтобы любой ответ сервера был валидным JSON.

```json
{
  "result": "object or value"
}
```

#### Список объектов

Элементы списка возвращаются в свойстве `result.items`. В result могут быть дополнительные данные,
например общее количество объектов для пагинации или количество страниц с учётом ограничений выборки.

```json
{
  "result": {
    "items": ["object or value", "object or value"],
    "count": 19822
  }
}
```

#### Ошибки

Поддержка всех HTTP кодов форматом не определется. Достаточно различать успешные 2xx и ошибочные запросы 4xxx
в соответсвии с логикой проекта.

Если сервер возвращает информацию об ошибке, то она прописывается в свойсте `error`. 
Свойство `error.data` содержит подробности об ошибке, например информацию про каждое ошибочное поле 
формы.

```json
{
  "error": {
    "code": "400.42143",
    "message": "Some error",
    "data": {
      "fields": [
        {"path": "profile.phone", "message": "Not unique", "code": "unique"},
        {"path": "profile.phone", "message": "Bad format", "code": "format"}
      ]
    }  
  }
}
```

Предполагается, что у одного поля формы может быть несколько разных ошибок. В предыдущем примере
все ошибки полей возвращаются массивом, а значение `path` элементов массива может дублироваться.

# Запрос

Спецификация определяет query параметры запроса для указания что выбрать, с каким 
условием, сортировокой и ограничением. Параметры опциональные, допускается их переименовывание
и применение дополнительных. URL запроса любой.

```
GET /objects?fields=name,author(age)&search[author.age]=18;30&sort=-name&limi=10&skip=0&lang=ru
```

# `fields`

Названия свойств и отношений объекта, которые нужно получить одним запросом.

> Альтернативные названия: data, props, select

В классическом REST API структура ответа жестко определяется сервером. Клиент получает лишние 
данные, либо сталкивается с нехваткой нужных. Например, связанные объекты нужно запрашивать 
отдельными запросами, имея их идентфикатор. Обработка параметра `fields` решает эту проблему. 
Одним запросом можно выбрать все необходимые связанные данные и не запрашивать лишние.

#### `fields =`

Если параметр `fields` не указан или равен пустой строке, то сервер возвращает минимальный набор 
данных исходя из своих настроек. Обычно возвращается только идентификатор объекта. 

```json
{
  "result": {
    "id": 1
  }
}
```

#### `fields = *`

Символ `*` указывает на выбор всех непосредственных свойств объекта. С учётом их доступности на 
сервере. Выборка свойств связанных объектов не выполняется - только их внешние ключи. 

```json
{
  "result": {
    "id": 1,
    "type": "some",
    "name": "Test object",
    "status": "new",
    "profile": {
      "phone":"+79996665544",
      "avatar":{
        "id": 23,
        "type": "file"
      }
    }
  }
}
```

В данном примере `profile` является вложенным объектом (не отношением), а аватарка является 
отношением на объект с типом `file` и идентификатором `23`. Для выборки свойств аватарки нужно их явно 
указать в `fields`.

#### `fields = prop1, prop2(prop3)`

Конкретные свойства объекта указываются через запятую. Допустимы пробелы, переводы строк, табы.
Для вложенности использются круглые скобки. Идентфикатор объекта возвращается всегда (свойства по
умолчанию).

```
GET /some/1?fields=name, profile(avatar(url, extension), prop3)
```
```json
{
  "result": {
    "id": 1,
    "name": "Test object",
    "profile": {
      "avatar": {
        "url": "/uploads/1928-212/5c2f3ed1fee590496c63759f.png",
        "extension": "png"
      },
      "prop3": null
    }
  }
}
```

Если запрашиваемое свойство у объекта отсутствует, то в ответе оно будет с null значением. 
То есть в любом случаи свойство возвращается.

#### `fields = items(prop), count`

Свойства списка. Если сервер возвращает список объектов, то `fields` применяется к каждому объекту списка. 
Чтобы одним запросом запросить свойства самого списка, например общее количество объектов, 
удовлетворяющих условию без ограничений, то запрашиваемые свойства нужно вложить в `items` и через
запятую указывать свойства списка. Структура ответа будет консистента запросу.

```
GET /some/1?fields=items(name, profile(phone)), count
```
```json
{
  "result": {
    "items": [
      {
        "id": 1,
        "name": "Test object",
        "profile": {
          "phone":"+79996665544"
        }
      },
      {
        "id": 3,
        "name": "Test object 3",
        "profile": {
          "phone":"+79996665555"
        }
      }
    ],
    "count": 105
  }
}
```

Какие именно свойства есть у списка зависит от реализации АПИ, по умолчанию доступен `count`. 
Можно реализовать выборку средних, минимальных значений, но чаще функции агрегации реализуются 
отдельными запросами.

#### `fields = !prop`

Исключение свойства. Если у объекта много свойств и только одно из них не требуется возвращать, то 
вместо перечисления длинного списка возвращаемых свойств с исключением одного, можно применить 
отрицание свойства. 

Сначала указывается, что нужны все свойства символом `*`, далее через запятую свойства, которое исключить
с символом `!`. Если не указать `*`, то исключение будет из свойств, возвращаемых по умолчанию.

```
GET /some/1?fields=*, !name, !profile
```
```json
{
  "result": {
    "id": 1,
    "type": "some",    
    "status": "new"
  }
}
```

#### `fields = prop(type1:prop1, type2:prop2)`

Зависимость от типа объекта. В списке запрашиваемых объектов одно и тоже отношение может отличаться 
типом связанного объекта.

Например, "объекты избранного" могут ссылаться на пользователя, статью, товар и прочие типы объектов. 
Соответственно, доступные свойства отношения будут различаться. Если в fields указать свойства
пользовтеля, то для статьи они окажутся `null`. 

Чтобы не возвращать `null`, нужно в fields указывать свойства для конкретного типа объекта.
Перед именем свойства указывается название типа объекта, разделяя двоеточием `:`

```
GET /favorites?fields=relative(user:surname, product:price(value, unit), product:title)
```  
```json
{
  "result": {
    "items": [
      {
        "_id": "5c2f3ed1fee590496c93779d",
        "relative": {
          "_id": "5c2f3ed1fee590496c935678",
          "_type": "user",
          "surname": "UserSurname"
        }
      },
      {
        "_id": "5c2f3ed1fee590496c93778f",
        "relative": {
          "_id": "5c2f3ed1fee590496c935608",
          "_type": "product",
          "price": {
            "value": 100,
            "unit": "USD"
          },
          "title": "ProductTitle"
        }
      }
    ]
  }
}
```

Тип можно указывать для любых свойств, не только свойств отношений. Например, пользователи могут 
отличаться типом за счёт наследования. В одном списке будут админы, менеджеры и другие типы 
пользователей с различными свойствами. Уместно применять типизацию в `fields` для выборки 
исключительных свойств, например, админа или менеджера.

#### `fields = comments(text, children(^))`

Рекурсивные шаблоны. Символом `^` указывается ссылка на перечень полей уровнем выше скобки. 
Используется для выборки рекурсивных отношений (иерархий). Например, у каждого комментария есть 
свойство children с вложенными комментриями, у которых тоже есть вложенные комментарии. 

Запрос без `^` выглядел бы так:

```
GET /news?fields=text, comments(text, children(text, children(text, children(text, children))
```

Примером выше описана выборка на три уровня вложеннности, но вложенность может быть гораздо больше.
Чтобы определить поля на любой уровень вложенности применяется ссылка на шаблон полей.

```
GET /news?fields=text, comments(text, children(^))
```

Ссылка относительная. Чтобы сделать ссылку на два и более уровней выше (на шаблон за второй скобкой), 
указывается соответсвующее количество символов `^`.

```
GET /product?fields=title, brand(name, products(title, brand(name, products()))
GET /product?fields=title, brand(name, products(^^))
```

# `search`

Условие выборки.

> Альтернативные названия: search, search, where

Параметром условия выборки указываются значения полей и способы сравнения значения со свойствами
объекта, напрмиер "больше или равно", "вхождение в диапазон", "перечисление значений" и другие. 
Допустимо указывать виртуальные поля, по которым формируются сложные условия на стороне бэкенда. 
Допустимые поля и условия для них определяет бэкенд. Назанчение параметра - передать бэку 
информацию, из которой будет формироваться полноценное условие поиска в базе данных.

Параметром можно указать несколько условий на разные поля. Поэтому применяется синтаксис квадратных
скобок. Формат не определет как логически услвоия будут объединться - И, ИЛИ, НЕ. Это зависит от
реализации сервера. Обычно улсовия объединяются через И. Но на усмотрнения бэкенда выборочные 
условия объдинять в соответсвии со спецификой запроса.

Условие равенства `search[prop1]=value` сервер может реализовывать по любой логике, не обязательно
строгим равенством00. Потомучто параметр search не стремиться определить все возможные условия, в ином 
случаи он станет сложным для использования и интерпретации бэком. 

> @todo: Отдельным параметром передавать логику объединения условий. Например 
```logic=price && (title || age)```

Условие может быть как на выбираемое множество объектов, так и на конкретное свойство объекта 
(обычно тоже множественное). Например, у товара множество точек продаж, выбирая сам товар, можем 
ограничить список точек продаж по определенному условию.

_Выборка товара с условием на него_
```
search[price]=100;200  // Цена в диапазоне от 100 до 200 включительно
search.stores[title]=*Magnit  // Магазины отфильтровать по названию - содержат Magnit
```

Через точку указывается, к какому свойству применить условие фильтра. Будет отфильтровано
само свойство у выбранных объектов. Если свойство не указано, то фильтр применяется к множеству 
запрашиваемых объектов. В квадратных скобках указывается свойство (или виртуальное поле), по 
которому будет сформировно условие фильтра.

## sort

Сортировка списков.

> Альтернативные названия: order

Параметром сортировки перечисляются поля с указанием направления сортировки.
Сортировать можно выбираемые объекты и их множественные свойства. Для сортировки свойств в названи
параметра sort через точку указывается свойство, которое сортировать. Свойства, по которым 
сортировать в строковом значении параметра.

_Сортировка товара и его свойства магазинов_
```
sort=-price,date // Сортировка по убыванию цены и возаратсанию даты
sort.stores=title // Список магазинов отсортировать по названию магазинов
```

## limit, skip

Ограничения списков

> Альтернативные названия: count, offset

Лимит и сдвиг ограничивают выборку объектов. Можно ограничить выборку множественных свойств объекта.

_Ограничение выбираемых товаров и их свойства магазинов_
```
limit=100
limit.stores=10

skip=10
skip.stores=0
```

## depth

Ограничение вложенности (глубины) при выборке иерерхических структур или рекурсивных связей.
Обычно указывается для свойств объекта.

_Выбор дерева страниц 2 уровня и комменответов на 4 уровня вложенности_
```
GET /pages?depth.chilren=2&depth.comments=4
```

Отсутствие параметра `depth` может трактоваться как выборка плоских данных, а при наличии depth c 
любым значением структуировать их в дерево, в качестве древовидных отношений бэкенд применятся
установки по умолчанию, например свойство children.

## lang, unit, version

Параметр языка для случаев с мультиязычными свойствами, чтобы вернуть объекты со свойствами
в нужном языке. Можно указать разные языки для конкретных свойств объекта. 

_Язык для товаров и названия магазинов_
```
lang=en // язык для всех свойств
lang.stores.title=ru  // язык для заголовка магазинов
```

Если указать all, то сервер должен вернуть объекты на всех языках и свойства на всех языках. В 
том случаи структура свойства зависит от модели. Предполагается, что образуется вложенность

```json
{
   "title": {
     "ru": "Заголвоок",
     "en": "Title",
     "it": "Testata"
   }
}
```

Параметр языка предагается как пример, по его подобию можно указывать валюту `unit` для цен, версию
изменений `ver` и другие.

## {custom}

Кастомные параметры предлагается реализовывать по образу и подобию предложенных форматов. 
Применять точки в названии для определений условий на соответсвующие свойства объектов.
Формат у значения параметра может быть любым, так как зависим от назначения, учитывать толкьо 
экранирование спец. символов URL.
